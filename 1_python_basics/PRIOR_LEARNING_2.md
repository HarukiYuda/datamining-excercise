# 事前学習その２: Numpyなどのモジュールの基本

### 他人の成果をありがたく使わせていただくためのモジュール

さて．Pythonが読みやすい，ということはわかってきたと思います．読みやすいだけではなく，Pythonには世界のどこかの人が作ってくれた機能や関数を利用できる仕組みがあります．データを解析するための様々な方法を簡単に利用できるように，誰かがすでに整備してくれている分けです．これがPythonを使う大きなメリットのひとつです．

こういった誰かが作ってくれて公開されているものを「パッケージ」とか「モジュール」と呼びます．

世の中にはとてもたくさんのモジュールが存在しています．やっぱり，すべてを前もって知る必要はないですし，実は似たような機能をもっているモジュールも多くあります．これはモジュールを誰かが管理しているわけではないからで，実は誰でも作って公開できます．だから似たようなモジュールもできてしまう，というわけです．

それでも主要な，というか，標準的なモジュールというものがあります．特に重要なものがNumpyです．
データを扱うためのモジュールはこのNumpyを使っていることがほとんどで，そのためにデータをNumpyの形式で揃えておく必要があったりもします．ということで，まずNumpyについて基本を押さえておきましょう．

Numpyも非常に奥が深く，Web上におかれているマニュアルを読み込めばいろいろなことができます．ただ，とりあえずはNumpyで書かれているプログラムをなんとなく読めるようになることを目標として，あとの細かいことはWebで調べる，ということにしておきましょう．

***
#### モジュールの読み込みと省略系の名前

さて，また次のコードを開きましょう（別タブなどで）．

[>> `04_numpy_check.py`](./04_numpy_check.py)

コード [`04_numpy_check.py`](./04_numpy_check.py) の1行目に
```python
import numpy as np
```
とあります．これがもっとも重要で，「`numpy` というモジュールを `np` という名前でこのコードに取り込む」という意味です．`import` は「輸入する」とか「取り込む」という英単語，`as` は「〜として」という意味だから，読むことは簡単ですよね．

なお，読み込んだモジュールを使う方法にもいくつかあるのですが，基本的には「モジュール名」にピリオドをつけてから「モジュールに書かれている命令」とか「モジュールに書かれている関数」を記載します．これはコード [`04_numpy_check.py`](./04_numpy_check.py) の4行目などを眺めればすぐにわかります．

また，モジュールを読み込む際は `np` という名前ではなくてもかまわないし，名前をつけなくてもかまいません．
```python
import numpy as mynumpy
```
とした場合には，それ以降のコードで `np` の代わりに`mynumpy`を使えばよいですし，単に
```python
import numpy
```
とした場合には名前をつけていないので， `np` ではなく，そのまま `numpy` を使えばよい，というだけのことです．

`as np` を使うことで，いちいち `numpy` と書く必要がなくなって，コードを書くのが少し楽になります．`np` すら書かなくて済ませる方法もありますが，自分が利用している機能が `numpy` からのものだ，と意識するためにも，`np` 程度の名前をつけておくコードが多いので，ここではひとまずそれにしたがっておきましょう．

***
#### Numpy 形式での配列作成とアクセス

コード [`04_numpy_check.py`](./04_numpy_check.py) の4行目と5行目を見ましょう．`array` というのは「整列」とか「配列」という意味の英単語です．Pythonのリスト形式，つまり数字を並べたものを `np.array( )` の括弧のなかに入れればnumpy用の配列を作ることができます．また，`reshape` は「形を変える」という英語です．実際に演習でプログラムを実行して，結果を見るとすぐに理解できるでしょう．Pythonのリスト形式 `mylist` から作られたnumpyでの `data` は `np.array` 形式，つまりnumpyでの1次元配列で，これを 3 &times; 3 の2次元配列に `reshape`するわけです．

また，配列の要素にアクセスする方法もPythonのリストと同じですから，コードを読むことはそれほど難しくないはずです．

***
#### 2次元配列は，配列の要素が「配列」

（ここは特に演習での結果を見ないとわからないと思いますので，一度目を通して，あとでここに戻ってください）

コード [`04_numpy_check.py`](./04_numpy_check.py) の10行目 `print(mat)` の出力結果は，試せばわかりますが，以下のようになります．
```python
[[ 1.1 2.2 3.3]
 [ 4.4 5.5 6.6]
 [ 7.7 8.8 9.9]]
```

さて，`mat = data.reshape(3,3)` で作った `mat` というのは2次元の配列なのですが，そもそも配列が2次元である，ということはどういうことでしょうか？

ここでは「1次元配列の要素が1次元配列である」と考えておきましょう．つまり，`data` というのは[要素0, 要素1, 要素2]からできていて，要素0というのが `[1.1 2.2 3.3]` という配列である，ということです．

配列は `[ ]` に要素を指定することで，その中身を見ることができました．2次元の場合には2つ要素を指定することになります．コード [`04_numpy_check.py`](./04_numpy_check.py) の12行目はわかりやすいのですが，14行目，`mat[0,:]` の意味は次のようになります．`:` は `[0:5]` のように「〜から〜まで」を指定するために使われていましたが，数字を書かなければ「最初から最後まで」，つまり「すべて」の意味になります．

- 1次元目については `0` という要素が指定されているので，「要素をゼロから数える」ことを考慮すれば『1番目の要素』のこと．つまり，1次元配列として[要素0, 要素1, 要素2]と考えた場合の要素0を指し示している．
- 2次元目については `:` だから，これは2次元目についての「すべての要素」を指し示している．
- 結果として，１次元目の要素0についてのすべて，ということで `[1.1 2.2 3.3]` となる．

そして結果の16行目の `mat[:,1]` は次のような感じです．

- 1次元目に対しては `:` という要素が指定されているから，1次元配列として[要素0, 要素1, 要素2]と考えた場合のすべての要素を指し示す．
- 2次元目の `1` については，『要素はゼロから数える』ということを考慮すれば『2番目の要素』を指し示す．
- 結果として，要素0, 要素1, 要素2のそれぞれの1次元配列の2番目の要素を並べたものだから  `[2.2 5.5 8.8]` となる．

少しややこしいですが，慣れればなんとかなります．忘れてもその都度Webで調べつつ，確認しながらで大丈夫です．とにかく `print` を使って，実際に出力して確認してみるのもいいでしょう．

***
#### Numpy は少し不自由だけれど，高速だし必須

Pythonのリストと同じように見えるこのnumpyモジュールですが，データを扱う上では必須です．リストとの違いは「数値の扱い」に特化していることです．

- リストと違って文字列を入れられない．そのぶん，数値についてはとにかく高速．
- リストは途中でサイズを増やす・減らすことが可能だけれど，numpy の配列は，`reshape`で形を変えることはできるものの，サイズの増減は基本的に許されない．
- リストとは違い，numpyの2次元配列では，2次元目はすべて同じサイズでなければいけない，などのルールもある．

・・などなど，細かい点はあるのですが，Pythonのリストをデータ解析のような「重い」計算に使おうとすると遅すぎて使えません．numpyが必須です．

これから紹介していくような機械学習用のモジュールでは，データの入力や出力がnumpyの形式でおこなわれることがほとんどで，そのためにnumpyの配列の作り方などの最低限の知識が必要になります．コード [`04_numpy_check.py`](./04_numpy_check.py) では，配列に対する演算なども例示していますが，これらについては「ほぼ直感的にできる」ということだけ今は押さえておけば十分です．データ解析の初歩ではこのような演算を自分で書く機会はあまりありません．データを整形するために使われることがほとんどです．

***
#### 行列のように扱えるnumpyの配列

コード [`04_numpy_check.py`](./04_numpy_check.py) を見ると，2次元配列を数学でいう「行列」として扱っているように思えてきます．行列というのは，単なる数字の集まりではなくて，足し算とか掛け算とか，「演算」が導入された数学の体系で，データ解析には必須の道具です．

実はnumpyには `numpy.matrix`（`np` として取り込んだ場合には `np.matrix` ）という行列を扱うための方法がきちんと用意されています．実際，`array` を使った場合と `matrix` を使った場合とで演算結果に違いが出てきたりもします．`array` はあくまでも「配列」であって，実は3次元とか4次元の配列もありえます．`matrix`は「行列」ですから，もちろん2次元までです．

実際のところ，データ解析では1次元とか2次元のデータを扱う場面が多くあります．2次元ならば行列，と思いますが，ただ，`matrix` よりは `array` がよく使われるようです．あとでモジュールのマニュアルを見ると，入出力が `array` 形式であることが多い，ということに気がつくでしょう．

***
#### データの前処理に必要な配列の整形作業

これまでpythonの命令は英語っぽく読めるものが多かったと思います．ただ，コード [`04_numpy_check.py`](./04_numpy_check.py) の34行目，36行目にある `np.c_` とか `np.r_` といった英単語らしくない命令も使われます．

これらは2つの配列を連結するために使わるもので，例えば二つのファイルから別々に読み込んだデータを一緒にまとめて解析するときなどには非常に便利なものです．でも，例えば2次元の配列の時には，連結する方向がいくつかあります．実際に演習の際に結果を見ると違いがわかります．

でも，どちらの命令だとどの方向に連結されるのかがわかりづらいですよね．実際に使う場合には，とりあえずどちらかを使ってみて，エラーメッセージを確認するか（2つの配列のサイズが連結に向いていないとか），`print` を使って連結される方向を確認するか，といったことで確認しながらプログラムを実行するのがよいでしょう．

実は，少し調べてみたのですが，`r_` と `c_` の意味が明示された情報源を見つけることはできませんでした（たぶん，どこかには書いてあると思いますが・・）．これは推測ですが，おそらく数学の行列でいう行(row)と列(column)のことだと思われます．数学で行列の要素を指定するときには「n行目m列目の要素」のように最初に「行」を指定し，次に「列」を指定します．だから `r_` の方は1次元目，つまり二重括弧の外側の方として連結されて，`c_` の方は2次元目，つまり二重括弧の内側が連結される，ということなのだと思われます．あくまで推測ですが・・．

***
### データ解析に必須となる結果のプロット

さて，pythonの基本も大詰めです．また次のコードを開きましょう（別タブなどで）．

[>> `05_plot_check.py`](./05_plot_check.py)

やっぱり結果が目に見えたほうがよいですよね．ということで，pythonには結果を図として表示するためのモジュールも用意されています．コード [`05_plot_check.py`](./05_plot_check.py) の2行目で
```python
import matplotlib.pyplot as plt
```
を使って，プロットするためのモジュールを `plt` という名前で読み込んでいます．

ここで `def` という，関数を定義するための命令が出てきてしまっていますが，`return` という英語は「返す」という意味ですし，`f(t)` という関数が `t` という値をもとに何かしら計算してからその結果を返すという，数学の関数なのかな，というくらいは読み取れるでしょう．細かいところはあとで各自で調べてみてください．

コード [`05_plot_check.py`](./05_plot_check.py) の7行目に `np.arange(0.0, 5.0, 0.1)` というnumpyの関数が使われています．`numpy arange` などで検索してみて欲しいのですが，これは「0.0 から 5.0 までを 0.1 刻みで分割した `numpy.array` 形式の配列を作る」というものです．あとで演習で試してみてください．

コード [`05_plot_check.py`](./05_plot_check.py) の10行目と11行目も詳しくは各自で調べて欲しいのですが，10行目は「x座標として `t1` を使い，y座標として `f(t1)` ，つまり `t1`（これはnumpyの配列）の各要素を，自分で定義した関数 `f(t)` に入れた出力を使って，`bo`，つまり `blue`（青色）で `o`（丸い記号）でプロットせよ」という命令が書かれています．

ちょっと細かい話を．例えばC言語に慣れた人には不思議に思えるかもしれませんが，関数 `f(t)` に配列を代入すると，pythonでは配列が出力されます．つまり，入力の形が配列なので，同じ関数を使ってまとめて計算してくれるわけですね．C言語なら `for` 文を書かないといけないところを，python ではかなり簡略化してコードを書ける，ということです．コード書きの生産性が上がりますね．

***
### 基本の終わりに

これまで，データ解析をするために最小限のpythonやモジュールの知識を記載してきました．プログラミングが苦手な人のなかには，全然わからない，という人もいるでしょう．また，プログラミングが得意な人は，逆にもう少ししっかりと書いて欲しかったと思うかもしれません．

何度も書いてきましたが，ここでの目的は，まずデータの解析に慣れることです．そのため，最初はコードの意味をなんとなく読み取って，自分の用途に応じて少し書き換えることができれば十分です．この教材ではそのための演習をおこないます．

そもそも，日々追加されるすべてのモジュールについてあらかじめ知っておくことなんて不可能ですし，そんな必要もありません．多くのモジュールを使う機会はありませんから．

関数とかクラスについても，そして有名なモジュール絡みのことについても，あらかじめすべてを勉強するのは大変ですし，学び始めの段階でそこまで目指す必要は全くありません．コードを「読む」だけならばそれらを完全にマスターする必要もありません．そして，基本的な機能やモジュール絡みのことであれば，Webで検索すれば簡単に情報が手に入ります．

まずは気楽にコードに向き合い，少しずつ足を踏み入れていってください．

***
### いつかは文化を理解して，貢献できるように

少し話が逸れますが，[『UNIXという考え方』(M. Gancarz著，芳尾 桂 監訳，オーム社)（外部リンク）](http://shop.ohmsha.co.jp/shopdetail/000000000309/) に書かれている話をここでひとつ紹介しておきます．

> あるソフトウェア技術者はとても一流とはいえないタイプで，基本的なものさえ満足に書くことはできなかったけれど，小さなプログラムをいくつもつなぎ合わせるコツを心得ていた．1日中コンピュータの前で昔誰かが作ったプログラムを眺め，使えそうなものを釣り上げて，それらをつなぎ合わせてプログラムを作るだけだったのに，傑出したソフトウェア技術者として上層部に認められるようになるまで時間はかからなかったらしい．

つまりは，そういうこと，ですね．「つなぎ合わせたり」「改良したり」するコツをつかんでいれば，
過去の遺産を「テコ」にして大きな仕事をできます．もちろん，著作権など商用利用には注意をしながら，ではありますが・・．

無料で使わせてもらって悪い気がする，と思うかもしれません．でも，すでに以前の注釈でも述べたようにこういう文化で成立している業界でもあります．まずは誰かの書いたコードやモジュールの新しい用途を見つけてみてはいかがでしょうか？ 用途が広がってそのコードやモジュールが有名になれば，製作者は喜ぶはずですよね．そしていつかはそういったコードやモジュールに改良を加えてあげれば，元の製作者はもっと喜ぶはずです．だから初心者のうちは，気にせずにコピィ＆ペーストをして，いくつかのコードを組み合わせたり改良したりする技術を身につけるのがいいと思います．少なくとも本教材を作成している「私」も，Pythonと向き合い始めたときの姿勢は，データ解析や機械学習のサンプルコードを読みながら自分の用途に合わせて改変したり，ほかのサンプルコードと組み合わせたり，といった実用的な技術を身につける練習を少しずつ進めることでした．

ご参考までに．

***
[>> Pythonの基本的な使い方のトップページに戻る](./README.md)
***
<img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"> &nbsp; Jun Ohkubo
